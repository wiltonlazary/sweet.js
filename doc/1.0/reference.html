<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Sweet Reference Documentation</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400">
<link rel="stylesheet" href="./stylesheets/asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Sweet Reference Documentation</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_command_line_api">2. Command Line API</a></li>
<li><a href="#_binding_forms">3. Binding Forms</a>
<ul class="sectlevel2">
<li><a href="#__code_syntax_code">3.1. <code>syntax</code></a></li>
<li><a href="#__code_syntaxrec_code">3.2. <code>syntaxrec</code></a></li>
</ul>
</li>
<li><a href="#_syntax_transformer">4. Syntax Transformer</a>
<ul class="sectlevel2">
<li><a href="#_transformer_context">4.1. Transformer Context</a></li>
</ul>
</li>
<li><a href="#_syntax_objects">5. Syntax Objects</a>
<ul class="sectlevel2">
<li><a href="#_val">5.1. val</a></li>
<li><a href="#_linenumber">5.2. lineNumber</a></li>
<li><a href="#_inner">5.3. inner</a></li>
<li><a href="#_from">5.4. from</a></li>
<li><a href="#_fromnull">5.5. fromNull</a></li>
<li><a href="#_fromnumber">5.6. fromNumber</a></li>
<li><a href="#_fromstring">5.7. fromString</a></li>
<li><a href="#_frompunctuator">5.8. fromPunctuator</a></li>
<li><a href="#_fromkeyword">5.9. fromKeyword</a></li>
<li><a href="#_fromidentifier">5.10. fromIdentifier</a></li>
<li><a href="#_fromregularexpression">5.11. fromRegularExpression</a></li>
<li><a href="#_frombraces">5.12. fromBraces</a></li>
<li><a href="#_frombrackets">5.13. fromBrackets</a></li>
<li><a href="#_fromparens">5.14. fromParens</a></li>
<li><a href="#_isidentifier">5.15. isIdentifier</a></li>
<li><a href="#_isbooleanliteral">5.16. isBooleanLiteral</a></li>
<li><a href="#_isnullliteral">5.17. isNullLiteral</a></li>
<li><a href="#_isnumericliteral">5.18. isNumericLiteral</a></li>
<li><a href="#_isstringliteral">5.19. isStringLiteral</a></li>
<li><a href="#_iskeyword">5.20. isKeyword</a></li>
<li><a href="#_ispunctuator">5.21. isPunctuator</a></li>
<li><a href="#_isregularexpression">5.22. isRegularExpression</a></li>
<li><a href="#_istemplate">5.23. isTemplate</a></li>
<li><a href="#_isdelimiter">5.24. isDelimiter</a></li>
<li><a href="#_isparens">5.25. isParens</a></li>
<li><a href="#_isbrackets">5.26. isBrackets</a></li>
<li><a href="#_isbraces">5.27. isBraces</a></li>
<li><a href="#_issyntaxtemplate">5.28. isSyntaxTemplate</a></li>
</ul>
</li>
<li><a href="#_syntax_templates">6. Syntax Templates</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is the reference document for Sweet.js. For a gentle explaination of Sweet&#8217;s concepts see the <a href="tutorial.html">tutorial</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_command_line_api">2. Command Line API</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>--out-file &lt;file&gt;</code>: write result to file</p>
</li>
<li>
<p><code>--out-dir &lt;dir&gt;</code>: write result to directory</p>
</li>
<li>
<p><code>--no-babel</code>: do not use babel backend</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_binding_forms">3. Binding Forms</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__code_syntax_code">3.1. <code>syntax</code></h3>
<div class="listingblock">
<div class="content">
<pre>syntax &lt;name&gt; = &lt;init&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Bind <code>&lt;name&gt;</code> to the result of evaluating <code>&lt;init&gt;</code> in the compiletime environment. Scoping follows <code>let</code> (i.e. block scoped with a temporal dead zone).</p>
</div>
<div class="paragraph">
<p>If the result of evaluating <code>&lt;init&gt;</code> is a function, then the result is a <a href="#syntax"><em>syntax transformer</em></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="__code_syntaxrec_code">3.2. <code>syntaxrec</code></h3>
<div class="listingblock">
<div class="content">
<pre>syntaxrec &lt;name&gt; = &lt;init&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Identical to the <code>syntax</code> form except that <code>&lt;name&gt;</code> is also bound inside of <code>&lt;init&gt;</code>. This enables recursive macro definitions.</p>
</div>
<div class="paragraph">
<p><a id="syntax"></a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax_transformer">4. Syntax Transformer</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>transformer : (TransformerContext) -&gt; List(Syntax)</pre>
</div>
</div>
<div class="paragraph">
<p>A syntax transformer is a function bound to a compile-time name. A syntax transformer is invoked with a <a href="#context"><strong>transformer context</strong></a> that provides access to the syntax at the call-site and returns a list of <a href="#synobj">syntax objects</a>.</p>
</div>
<div class="paragraph">
<p><a id="context"></a></p>
</div>
<div class="sect2">
<h3 id="_transformer_context">4.1. Transformer Context</h3>
<div class="paragraph">
<p>A transformer context is an iterable object that provides access to syntax at the call-site of a syntax transformer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>TransformerContext = {
  name: () -&gt; Syntax
  next: () -&gt; {
    done: boolean,
    value: Syntax
  }
  expand: (string) -&gt; {
    done: boolean,
    value: Syntax
  }
  mark: () -&gt; Marker
  reset: (Marker?) -&gt; undefined
}</pre>
</div>
</div>
<div class="paragraph">
<p>Each call to <code>next</code> returns the <a href="#synobj">syntax object</a> following the transformer call.</p>
</div>
<div class="paragraph">
<p>A call to <code>expand</code> initiates expansion at the current state of the iterator and matches the specified grammar production. Matching is "greedy" so <code>expand('expr')</code> with the syntax <code>1 + 2</code> matches the entire binary expression rather than just <code>1</code>. The following productions are accepted by <code>expand</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Statement</code> with alias <code>stmt</code></p>
</li>
<li>
<p><code>AssignmentExpression</code> with alias <code>expr</code></p>
</li>
<li>
<p><code>Expression</code></p>
</li>
<li>
<p><code>BlockStatement</code></p>
</li>
<li>
<p><code>WhileStatement</code></p>
</li>
<li>
<p><code>IfStatement</code></p>
</li>
<li>
<p><code>ForStatement</code></p>
</li>
<li>
<p><code>SwitchStatement</code></p>
</li>
<li>
<p><code>BreakStatement</code></p>
</li>
<li>
<p><code>ContinueStatement</code></p>
</li>
<li>
<p><code>DebuggerStatement</code></p>
</li>
<li>
<p><code>WithStatement</code></p>
</li>
<li>
<p><code>TryStatement</code></p>
</li>
<li>
<p><code>ThrowStatement</code></p>
</li>
<li>
<p><code>ClassDeclaration</code></p>
</li>
<li>
<p><code>FunctionDeclaration</code></p>
</li>
<li>
<p><code>LabeledStatement</code></p>
</li>
<li>
<p><code>VariableDeclarationStatement</code></p>
</li>
<li>
<p><code>ReturnStatement</code></p>
</li>
<li>
<p><code>ExpressionStatement</code></p>
</li>
<li>
<p><code>YieldExpression</code></p>
</li>
<li>
<p><code>ClassExpression</code></p>
</li>
<li>
<p><code>ArrowExpression</code></p>
</li>
<li>
<p><code>NewExpression</code></p>
</li>
<li>
<p><code>ThisExpression</code></p>
</li>
<li>
<p><code>FunctionExpression</code></p>
</li>
<li>
<p><code>IdentifierExpression</code></p>
</li>
<li>
<p><code>LiteralNumericExpression</code></p>
</li>
<li>
<p><code>LiteralInfinityExpression</code></p>
</li>
<li>
<p><code>LiteralStringExpression</code></p>
</li>
<li>
<p><code>TemplateExpression</code></p>
</li>
<li>
<p><code>LiteralBooleanExpression</code></p>
</li>
<li>
<p><code>LiteralNullExpression</code></p>
</li>
<li>
<p><code>LiteralRegExpExpression</code></p>
</li>
<li>
<p><code>ObjectExpression</code></p>
</li>
<li>
<p><code>ArrayExpression</code></p>
</li>
<li>
<p><code>UnaryExpression</code></p>
</li>
<li>
<p><code>UpdateExpression</code></p>
</li>
<li>
<p><code>BinaryExpression</code></p>
</li>
<li>
<p><code>StaticMemberExpression</code></p>
</li>
<li>
<p><code>ComputedMemberExpression</code></p>
</li>
<li>
<p><code>AssignmentExpression</code></p>
</li>
<li>
<p><code>CompoundAssignmentExpression</code></p>
</li>
<li>
<p><code>ConditionalExpression</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>name()</code> method returns the syntax object of the macro name at the macro invocation site. This is useful<span class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</span> because it allows a macro transformer to get access to the lexical context at the invocation site.</p>
</div>
<div class="paragraph">
<p>A call to <code>mark</code> returns a pointer to the current state of the iterator.</p>
</div>
<div class="paragraph">
<p>Calling <code>reset</code> with no arguments returns the context to its initial state, while passing a Marker instance returns the context to the state pointed to by the marker.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = function (ctx) {
  ctx.expand('expr');
  ctx.reset();

  const a = ctx.next().value;
  ctx.next();

  const marker = ctx.mark();
  ctx.expand('expr');
  ctx.reset(marker);

  const b = ctx.next().value;
  return #`${a} + ${b} + 24`; // 30 + 42 + 24
}
m 30 + 42 + 66</code></pre>
</div>
</div>
<div class="paragraph">
<p><a id="synobj"></a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax_objects">5. Syntax Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Syntax objects represent the syntax from the source program. Syntax objects have a number of methods to inspect their contents and construct new syntax object.</p>
</div>
<div class="sect2">
<h3 id="_val">5.1. val</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.val() -&gt; string?</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns a nullable value representing the textual value of the syntax object. For example, the <code>.val()</code> of the identifier <code>foo</code> is the string <code>"foo"</code>. Some syntax objects (in particular delimiters) do not have a reasonable representation of their syntax and so <code>.val()</code> returns <code>null</code> in these cases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let id = ctx.next().value;
  let delim = ctx.next().value;

  id.val() === 'foo';   // true
  delim.val() === null; // true
  // ...
}
m foo (1)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_linenumber">5.2. lineNumber</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.lineNumber() -&gt; number</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns the original line number for this syntax object.</p>
</div>
</div>
<div class="sect2">
<h3 id="_inner">5.3. inner</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.inner() -&gt; TransformerContext</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the syntax object is a delimiter, returns a <a href="#context">transformer context</a> iterator into the delimiter. Otherwise, throw an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let delim = ctx.next().value;
  var arr = [];
  for (let item of delim.inner()) {
    arr.push(item);
  }
  return #`[${arr}]`;
}
m {
  1, 2, 3
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_from">5.4. from</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.from(type, value) -&gt; Syntax
  type : string
  value : any</code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a new syntax object from the provided <code>type</code> and <code>value</code> using the instance syntax object&#8217;s lexical context. Valid types are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>'null'</code></p>
</li>
<li>
<p><code>'number'</code></p>
</li>
<li>
<p><code>'string'</code></p>
</li>
<li>
<p><code>'punctuator'</code></p>
</li>
<li>
<p><code>'keyword'</code></p>
</li>
<li>
<p><code>'identifier'</code></p>
</li>
<li>
<p><code>'regularExpression'</code></p>
</li>
<li>
<p><code>'braces'</code></p>
</li>
<li>
<p><code>'brackets'</code></p>
</li>
<li>
<p><code>'parens'</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful which syntax object you use to create a new syntax object via <code>from*</code> since the new object will share the original&#8217;s lexical context. In most cases you will want to create a "dummy" syntax object inside a macro definition and then use that as a base to create new objects. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax to_str = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  let arg = ctx.next().value;
  return #`${dummy.fromString(arg.val())}`;
}
to_str foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be tempted to reuse the syntax object provided by <code>ctx.name()</code> but resist that feeling! The <code>ctx.name()</code> syntax object comes from the macro call-site and so any syntax objects created from it will carry the lexical context of the call-site. Sometimes this is what you want, but most of the time this breaks hygiene!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_fromnull">5.5. fromNull</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromNull() -&gt; Syntax</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a null literal with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  return #`${dummy.fromNull()}`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>null</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fromnumber">5.6. fromNumber</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromNumber(value) -&gt; Syntax
  value : number</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a numeric literal matching <code>value</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  return #`${dummy.fromNumber(1)}`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fromstring">5.7. fromString</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromString(value) -&gt; Syntax
  value : string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a string literal matching <code>value</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax to_str = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  let arg = ctx.next().value;
  return #`${dummy.fromString(arg.val())}`;
}
to_str foo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>'foo'</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_frompunctuator">5.8. fromPunctuator</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromPunctuator(value) -&gt; Syntax
  value : string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a punctuator (e.g. <code>+</code>, <code>==</code>, etc.) matching <code>value</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  return #`1 ${dummy.fromPunctuator('+')} 1`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>1 + 1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fromkeyword">5.9. fromKeyword</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromKeyword(value) -&gt; Syntax
  value : string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a keyword matching <code>value</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  return #`${dummy.fromKeyword('let')} x = 1`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>let x = 1</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fromidentifier">5.10. fromIdentifier</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromIdentifier(value) -&gt; Syntax
  value : string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a identifier matching <code>value</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  let arg = ctx.next().value;
  return #`${dummy.fromIdentifier(arg.val())}`;
}
m foo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>foo</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fromregularexpression">5.11. fromRegularExpression</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromRegularExpression(value) -&gt; Syntax
  value : string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a regular expression literal matching <code>value</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  return #`${dummy.fromRegularExpression('[a-zA-Z]*')}`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>/[a-zA-Z]/</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_frombraces">5.12. fromBraces</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromBraces(inner) -&gt; Syntax
  inner : List(Syntax)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a curly brace delimiter with inner syntax objects <code>inner</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  let block = #`let x = 1;`;
  return #`${dummy.fromBraces(block)}`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>{
  let x = 1;
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_frombrackets">5.13. fromBrackets</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromBrackets(inner) -&gt; Syntax
  inner : List(Syntax)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a square bracket delimiter with inner syntax objects <code>inner</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  let elements = #`1, 2, 3`;
  return #`${dummy.fromBrackets(elements)}`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>[1, 2, 3]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fromparens">5.14. fromParens</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.fromParens(inner) -&gt; Syntax
  inner : List(Syntax)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a parenthesis delimiter with inner syntax objects <code>inner</code> with the instance syntax object&#8217;s lexical context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = ctx =&gt; {
  let dummy = #`dummy`.get(0);
  let expr = #`5 * 5`;
  return #`1 + ${dummy.fromParens(expr)}`;
}
m</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">(expansion)</div>
<div class="content">
<pre>1 + (5 * 5)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_isidentifier">5.15. isIdentifier</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isIdentifier() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is an identifier.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isbooleanliteral">5.16. isBooleanLiteral</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isBooleanLiteral() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a boolean literal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isnullliteral">5.17. isNullLiteral</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isNullLiteral() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a null literal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isnumericliteral">5.18. isNumericLiteral</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isNumericLiteral() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a numeric literal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isstringliteral">5.19. isStringLiteral</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isStringLiteral() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a string literal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_iskeyword">5.20. isKeyword</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isKeyword() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a keyword.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ispunctuator">5.21. isPunctuator</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isPunctuator() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a puncuator.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isregularexpression">5.22. isRegularExpression</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isRegularExpression() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a regular expression literal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_istemplate">5.23. isTemplate</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isTemplate() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a template literal.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isdelimiter">5.24. isDelimiter</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isDelimiter() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a delimiter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_isparens">5.25. isParens</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isParens() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a parenthesis delimiter (e.g. <code>( &#8230;&#8203; )</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_isbrackets">5.26. isBrackets</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isBrackets() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a bracket delimiter (e.g. <code>[ &#8230;&#8203; ]</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_isbraces">5.27. isBraces</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isBraces() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a braces delimiter (e.g. <code>{ &#8230;&#8203; }</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_issyntaxtemplate">5.28. isSyntaxTemplate</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">Syntax.prototype.isSyntaxTemplate() -&gt; boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns true if the syntax object is a syntax template.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntax_templates">6. Syntax Templates</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Syntax templates construct a list of syntax objects from a literal representation using backtick (<code>#`foo bar baz`</code>). They are similar to ES2015 templates but with the special sweet.js specific <code>#</code> template tag.</p>
</div>
<div class="paragraph">
<p>Syntax templates support interpolations just like normal templates via <code>${&#8230;&#8203;}</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">syntax m = function (ctx) {
  return #`${ctx.next().value} + 24`;
}
m 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expressions inside an interpolation must evaluate to a <a href="#synobj">syntax object</a>, an array, a list, or an <a href="#context">transformer context</a>.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. or will become useful as more features are implemented in Sweet
</div>
</div>
</body>
</html>