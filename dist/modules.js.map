{"version":3,"sources":["modules.js"],"names":[],"mappings":";;;;;;;;;AAAA;;AACA;;;;AACA;;;;AACA;;IAAY;;AACZ;;;;AACA;;;;AACA;;;;AAKA;;;;;;;;;;IAEM;AACJ,WADI,MACJ,CAAY,eAAZ,EAA6B,aAA7B,EAA4C,aAA5C,EAA2D,IAA3D,EAAiE;0BAD7D,QAC6D;;AAC/D,SAAK,eAAL,GAAuB,eAAvB,CAD+D;AAE/D,SAAK,aAAL,GAAqB,aAArB,CAF+D;AAG/D,SAAK,aAAL,GAAqB,aAArB,CAH+D;AAI/D,SAAK,IAAL,GAAY,IAAZ,CAJ+D;GAAjE;;;;;eADI;;0BASE,SAAS;;AAEb,WAAK,aAAL,CAAmB,OAAnB,CAA2B,cAAM;AAC/B,YAAI,gCAAoB,GAAG,WAAH,CAApB,IAAuC,mCAAuB,GAAG,WAAH,CAA9D,EAA+E;AACjF,aAAG,WAAH,CAAe,WAAf,CAA2B,OAA3B,CACE,0BAAW,EAAE,EAAF,EAAM,OAAjB,EAA0B,QAAQ,KAAR,CAD5B,EADiF;SAAnF;OADyB,CAA3B,CAFa;;AAUb,aAAO,QAAQ,KAAR,CAVM;;;;;;;;;;SATX;;;AA4BN,IAAM,cAAc,UAAd;;IAEO;AACX,WADW,OACX,GAAc;0BADH,SACG;;AACZ,SAAK,aAAL,GAAqB,IAAI,GAAJ,EAArB,CADY;GAAd;;;;;eADW;;yBAMN,YAAY,SAAS;;;AACxB,UAAI,OAAO,QAAQ,cAAR,CAAuB,UAAvB,EAAmC,QAAQ,GAAR,CAA1C,CADoB;AAExB,UAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,CAAD,EAA+B;AACjC,YAAI,SAAS,QAAQ,YAAR,CAAqB,IAArB,CAAT,CAD6B;AAEjC,YAAI,CAAC,YAAY,IAAZ,CAAiB,MAAjB,CAAD,EAA2B;;AAE7B,eAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,EAA6B,IAAI,MAAJ,CAAW,IAAX,EAAiB,sBAAjB,EAAyB,sBAAzB,EAAiC,sBAAjC,CAA7B,EAF6B;SAA/B,MAGO;;AACL,gBAAI,SAAS,0BAAW,MAAX,CAAT;AACJ,gBAAI,OAAO,OAAO,IAAP,GAAc,KAAd,CAAoB,CAApB,CAAP;AACJ,gBAAI,gBAAgB,4BAAkB,EAAE,KAAF,CAAQ,OAAR,EAAiB;;AAErD,mBAAK,mBAAL;AACA,qBAAO,mBAAP;AACA,wBAAU,0BAAV;aAJoC,CAAlB,CAAhB;AAMJ,gBAAI,QAAQ,cAAc,MAAd,CAAqB,IAArB,CAAR;AACJ,gBAAI,gBAAgB,EAAhB;AACJ,gBAAI,gBAAgB,EAAhB;AACJ,kBAAM,OAAN,CAAc,aAAK;AACjB,gBAAE,IAAF,CAAO,CACL,kBAAW;uBAAK,cAAc,IAAd,CAAmB,CAAnB;eAAL,CADN,EAEL,kBAAW;uBAAK,cAAc,IAAd,CAAmB,CAAnB;eAAL,CAFN,CAAP,EAGG,CAHH,EADiB;aAAL,CAAd;AAMA,kBAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,EAA6B,IAAI,MAAJ,CAC3B,IAD2B,EAE3B,qBAAK,aAAL,CAF2B,EAG3B,qBAAK,aAAL,CAH2B,EAI3B,KAJ2B,CAA7B;eAlBK;SAHP;OAFF;AA+BA,aAAO,KAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,CAAP,CAjCwB;;;;SANf","file":"modules.js","sourcesContent":["import { List } from 'immutable';\nimport Env from \"./env\";\nimport Reader from \"./shift-reader\";\nimport * as _ from \"ramda\";\nimport TokenExpander from './token-expander.js';\nimport BindingMap from \"./binding-map.js\";\nimport Term, {\n  isEOF, isBindingIdentifier, isFunctionDeclaration, isFunctionExpression,\n  isFunctionTerm, isFunctionWithName, isSyntaxDeclaration, isSyntaxrecDeclaration, isVariableDeclaration,\n  isVariableDeclarationStatement, isImport, isExport\n} from \"./terms\";\nimport loadSyntax from './load-syntax';\n\nclass Module {\n  constructor(moduleSpecifier, importEntries, exportEntries, body) {\n    this.moduleSpecifier = moduleSpecifier;\n    this.importEntries = importEntries;\n    this.exportEntries = exportEntries;\n    this.body = body;\n  }\n\n  // put all compiltime transforms in the returned store\n  visit(context) {\n\n    this.exportEntries.forEach(ex => {\n      if (isSyntaxDeclaration(ex.declaration) || isSyntaxrecDeclaration(ex.declaration)) {\n        ex.declaration.declarators.forEach(\n          loadSyntax(_.__, context, context.store)\n        );\n      }\n    });\n\n    return context.store;\n  }\n\n  // invoke(context) {\n  //   // todo\n  //   this.exportEntries\n  // }\n}\n\nconst pragmaRegep = /^\\s*#\\w*/;\n\nexport class Modules {\n  constructor() {\n    this.loadedModules = new Map();\n  }\n\n  // ... -> { body: [Term], importEntries: [Import], exportEntries: [Export] }\n  load(modulePath, context) {\n    let path = context.moduleResolver(modulePath, context.cwd);\n    if (!this.loadedModules.has(path)) {\n      let modStr = context.moduleLoader(path);\n      if (!pragmaRegep.test(modStr)) {\n        // modules with out a #lang pragma need to be ignored\n        this.loadedModules.set(path, new Module(path, List(), List(), List()));\n      } else {\n        let reader = new Reader(modStr);\n        let stxl = reader.read().slice(3);\n        let tokenExpander = new TokenExpander(_.merge(context, {\n          // expand with a fresh environment\n          env: new Env(),\n          store: new Env(),\n          bindings: new BindingMap()\n        }));\n        let terms = tokenExpander.expand(stxl);\n        let importEntries = [];\n        let exportEntries = [];\n        terms.forEach(t => {\n          _.cond([\n            [isImport, t => importEntries.push(t)],\n            [isExport, t => exportEntries.push(t)]\n          ])(t);\n        });\n        this.loadedModules.set(path, new Module(\n          path,\n          List(importEntries),\n          List(exportEntries),\n          terms\n        ));\n      }\n    }\n    return this.loadedModules.get(path);\n  }\n}\n"],"sourceRoot":"/source/"}