{"version":3,"sources":["terms.js"],"names":[],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AACA;;IAAY;;;;;;;;;AAGV,kBAAY,IAAZ,EAAkB,KAAlB,EAAyB;;;AACvB,SAAK,IAAL,GAAY,IAAZ,CADuB;AAEvB,SAAK,GAAL,GAAW,IAAX;;AAFuB;;;;;AAIvB,2BAAiB,OAAO,IAAP,CAAY,KAAZ,2BAAjB,oGAAqC;YAA5B,mBAA4B;;AACnC,aAAK,IAAL,IAAa,MAAM,IAAN,CAAb,CADmC;OAArC;;;;;;;;;;;;;;KAJuB;GAAzB;;;;6BAQS,OAAO,UAAU,SAAS;;AAEjC,aAAO,IAAP,CAFiC;;;;;;;;AAO9B,IAAM,wBAAQ,EAAE,OAAF,CAAU,EAAE,MAAM,KAAN,EAAZ,CAAR;AACN,IAAM,wDAAwB,EAAE,OAAF,CAAU,EAAE,MAAM,qBAAN,EAAZ,CAAxB;AACN,IAAM,0EAAiC,EAAE,OAAF,CAAU,EAAE,MAAM,8BAAN,EAAZ,CAAjC;AACN,IAAM,oDAAsB,EAAE,IAAF,CAAO,qBAAP,EAA8B,EAAE,OAAF,CAAU,EAAE,MAAM,QAAN,EAAZ,CAA9B,CAAtB;AACN,IAAM,0DAAyB,EAAE,IAAF,CAAO,qBAAP,EAA8B,EAAE,OAAF,CAAU,EAAE,MAAM,WAAN,EAAZ,CAA9B,CAAzB;AACN,IAAM,wDAAwB,EAAE,OAAF,CAAU,EAAE,MAAM,qBAAN,EAAZ,CAAxB;AACN,IAAM,sDAAuB,EAAE,OAAF,CAAU,EAAE,MAAM,oBAAN,EAAZ,CAAvB;AACN,IAAM,0CAAiB,EAAE,MAAF,CAAS,qBAAT,EAAgC,oBAAhC,CAAjB;AACN,IAAM,kDAAqB,EAAE,GAAF,CAAM,cAAN,EAAsB,EAAE,UAAF,CAAa,EAAE,KAAF,CAAQ,EAAE,MAAM,EAAE,KAAF,EAAhB,CAAb,CAAtB,CAArB;AACN,IAAM,oDAAsB,EAAE,KAAF,CAAQ,EAAE,MAAM,EAAE,EAAF,kBAAN,EAAV,CAAtB;AACN,IAAM,0CAAiB,EAAE,OAAF,CAAU,EAAE,MAAM,cAAN,EAAZ,CAAjB;AACN,IAAM,4CAAkB,EAAE,OAAF,CAAU,EAAE,MAAM,eAAN,EAAZ,CAAlB;AACN,IAAM,oEAA8B,EAAE,OAAF,CAAU,EAAE,MAAM,2BAAN,EAAZ,CAA9B;AACN,IAAM,gEAA4B,EAAE,OAAF,CAAU,EAAE,MAAM,yBAAN,EAAZ,CAA5B;AACN,IAAM,8BAAW,EAAE,OAAF,CAAU,EAAE,MAAM,QAAN,EAAZ,CAAX;AACN,IAAM,8BAAW,EAAE,OAAF,CAAU,EAAE,MAAM,QAAN,EAAZ,CAAX","file":"terms.js","sourcesContent":["import { List } from \"immutable\";\nimport { assert, expect } from \"./errors\";\nimport { mixin } from \"./utils\";\nimport Syntax from \"./syntax\";\nimport * as R from \"ramda\";\n\nexport default class {\n  constructor(type, props) {\n    this.type = type;\n    this.loc = null;\n    // this._fields = Object.keys(props);\n    for (let prop of Object.keys(props)) {\n      this[prop] = props[prop];\n    }\n  }\n  addScope(scope, bindings, options) {\n    // todo: deal with hygiene here\n    return this;\n  }\n}\n\n\nexport const isEOF = R.whereEq({ type: 'EOF' });\nexport const isVariableDeclaration = R.whereEq({ type: 'VariableDeclaration' });\nexport const isVariableDeclarationStatement = R.whereEq({ type: 'VariableDeclarationStatement' });\nexport const isSyntaxDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: 'syntax' }));\nexport const isSyntaxrecDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: 'syntaxrec' }));\nexport const isFunctionDeclaration = R.whereEq({ type: 'FunctionDeclaration' });\nexport const isFunctionExpression = R.whereEq({ type: 'FunctionExpression' });\nexport const isFunctionTerm = R.either(isFunctionDeclaration, isFunctionExpression);\nexport const isFunctionWithName = R.and(isFunctionTerm, R.complement(R.where({ name: R.isNil })));\nexport const isBindingIdentifier = R.where({ name: R.is(Syntax) });\nexport const isArrayBinding = R.whereEq({ type: 'ArrayBinding' });\nexport const isObjectBinding = R.whereEq({ type: 'ObjectBinding' });\nexport const isBindingPropertyIdentifier = R.whereEq({ type: 'BindingPropertyIdentifier' });\nexport const isBindingPropertyProperty = R.whereEq({ type: 'BindingPropertyProperty' });\nexport const isImport = R.whereEq({ type: 'Import' });\nexport const isExport = R.whereEq({ type: 'Export' });\n"],"sourceRoot":"/source/"}