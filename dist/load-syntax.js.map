{"version":3,"sources":["load-syntax.js"],"names":[],"mappings":"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","file":"load-syntax.js","sourcesContent":["import * as _ from 'ramda';\nimport TermExpander from './term-expander';\nimport { List } from 'immutable';\nimport ParseReducer from './parse-reducer.js';\nimport reducer, { MonoidalReducer } from \"shift-reducer\";\nimport { makeDeserializer } from './serializer';\nimport Syntax from \"./syntax\";\nimport codegen, { FormattedCodeGen } from 'shift-codegen';\nimport { VarBindingTransform, CompiletimeTransform } from './transforms';\nimport Term, {\n  isEOF, isBindingIdentifier, isFunctionDeclaration, isFunctionExpression,\n  isFunctionTerm, isFunctionWithName, isSyntaxDeclaration, isVariableDeclaration,\n  isVariableDeclarationStatement, isImport, isExport\n} from \"./terms\";\nimport Reader from './shift-reader';\n\nimport { unwrap } from './macro-context';\n\nimport { replaceTemplate } from './template-processor';\n\n// indirect eval so in the global scope\nlet geval = eval;\n\nexport function sanitizeReplacementValues(values) {\n  if (Array.isArray(values)) {\n    return sanitizeReplacementValues(List(values));\n  } else if (List.isList(values)) {\n    return values.map(sanitizeReplacementValues);\n  } else if (values == null) {\n    throw new Error(\"replacement values for syntax template must not but null or undefined\");\n  } else if (typeof values.next === 'function') {\n    return sanitizeReplacementValues(List(values));\n  }\n  return unwrap(values);\n}\n\n// (Expression, Context) -> [function]\nfunction loadForCompiletime(expr, context) {\n  let deserializer = makeDeserializer(context.bindings);\n  let sandbox = {\n    syntaxQuote: function (strings, ...values) {\n      let ctx = deserializer.read(_.last(values));\n      let reader = new Reader(strings, ctx.context, _.take(values.length - 1, values));\n      return reader.read();\n    },\n    syntaxTemplate: function(str, ...values) {\n      return replaceTemplate(deserializer.read(str), sanitizeReplacementValues(values));\n    }\n  };\n\n  let sandboxKeys = List(Object.keys(sandbox));\n  let sandboxVals = sandboxKeys.map(k => sandbox[k]).toArray();\n\n  let parsed = reducer(new ParseReducer(), new Term(\"Module\", {\n    directives: List(),\n    items: List.of(new Term(\"ExpressionStatement\", {\n      expression: new Term(\"FunctionExpression\", {\n        isGenerator: false,\n        name: null,\n        params: new Term(\"FormalParameters\", {\n          items: sandboxKeys.map(param => {\n            return new Term(\"BindingIdentifier\", {\n              name: Syntax.fromIdentifier(param)\n            });\n          }),\n          rest: null\n        }),\n        body: new Term(\"FunctionBody\", {\n          directives: List.of(new Term('Directive', {\n            rawValue: 'use strict'\n          })),\n          statements: List.of(new Term(\"ReturnStatement\", {\n            expression: expr\n          }))\n        })\n      })\n    }))\n  }));\n\n  // TODO: should just pass an AST to babel but the estree converter still\n  // needs some work so until then just gen a string\n  // let estree = convert.toSpiderMonkey(parsed);\n  // let result = transform.fromAst(wrapForCompiletime(estree, sandboxKeys));\n\n  // let result = babel.transform(wrapForCompiletime(estree, sandboxKeys));\n  let gen = codegen(parsed, new FormattedCodeGen);\n  let result = context.transform(gen);\n  return geval(result.code).apply(undefined, sandboxVals);\n}\n\n// function wrapForCompiletime(ast, keys) {\n//   // todo: hygiene\n//   let params = keys.map(k => new Identifier(k));\n//   let body = new ReturnStatement(ast);\n//   let fn = new FunctionExpression(null, params, new BlockStatement([body]));\n//   return new Program([new ExpressionStatement(fn)]);\n// }\n\nconst loadSyntax = _.cond([\n  [_.where({binding: isBindingIdentifier}), _.curry(({binding, init}, context, env) => {\n    // finish the expansion early for the initialization\n    let termExpander = new TermExpander(context);\n    let initValue = loadForCompiletime(termExpander.expand(init), context);\n\n    env.set(binding.name.resolve(), new CompiletimeTransform(initValue));\n  })],\n  [_.T, _ => assert(false, \"not implemented yet\")]\n]);\n\nexport default loadSyntax;\n"],"sourceRoot":"/source/"}