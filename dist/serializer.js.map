{"version":3,"sources":["serializer.js"],"names":[],"mappings":"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","file":"serializer.js","sourcesContent":["import transit from \"transit-js\";\nimport { List } from \"immutable\";\nimport Syntax from \"./syntax\";\nimport { Symbol, gensym, SymbolClass } from \"./symbol\";\nimport { TokenClass, TokenType } from \"shift-parser/dist/tokenizer\";\n\nlet typeMap = [TokenType.STRING, TokenType.EOS, TokenType.LPAREN, TokenType.RPAREN,\n               TokenType.LBRACK, TokenType.RBRACK, TokenType.LBRACE, TokenType.RBRACE,\n               TokenType.COLON, TokenType.SEMICOLON, TokenType.PERIOD, TokenType.ELLIPSIS,\n               TokenType.ARROW, TokenType.CONDITIONAL, TokenType.INC, TokenType.DEC,\n               TokenType.ASSIGN, TokenType.ASSIGN_BIT_OR, TokenType.ASSIGN_BIT_XOR,\n               TokenType.ASSIGN_BIT_AND, TokenType.ASSIGN_SHL, TokenType.ASSIGN_SHR,\n               TokenType.ASSIGN_SHR_UNSIGNED, TokenType.ASSIGN_ADD, TokenType.ASSIGN_SUB,\n               TokenType.ASSIGN_MUL, TokenType.ASSIGN_DIV, TokenType.ASSIGN_MOD,\n               TokenType.COMMA, TokenType.OR, TokenType.AND, TokenType.BIT_OR,\n               TokenType.BIT_XOR, TokenType.BIT_AND, TokenType.SHL, TokenType.SHR,\n               TokenType.SHR_UNSIGNED, TokenType.ADD, TokenType.SUB, TokenType.MUL,\n               TokenType.DIV, TokenType.MOD, TokenType.EQ, TokenType.NE,\n               TokenType.EQ_STRICT, TokenType.NE_STRICT, TokenType.LT, TokenType.GT,\n               TokenType.LTE, TokenType.GTE, TokenType.INSTANCEOF, TokenType.IN,\n               TokenType.NOT, TokenType.BIT_NOT, TokenType.AWAIT, TokenType.DELETE,\n               TokenType.TYPEOF, TokenType.VOID, TokenType.BREAK, TokenType.CASE,\n               TokenType.CATCH, TokenType.CLASS, TokenType.CONTINUE, TokenType.DEBUGGER,\n               TokenType.DEFAULT, TokenType.DO, TokenType.ELSE, TokenType.EXPORT,\n               TokenType.EXTENDS, TokenType.FINALLY, TokenType.FOR, TokenType.FUNCTION,\n               TokenType.IF, TokenType.IMPORT, TokenType.LET, TokenType.NEW,\n               TokenType.RETURN, TokenType.SUPER, TokenType.SWITCH, TokenType.THIS,\n               TokenType.THROW, TokenType.TRY, TokenType.VAR, TokenType.WHILE,\n               TokenType.WITH, TokenType.NULL, TokenType.TRUE, TokenType.FALSE,\n               TokenType.YIELD, TokenType.NUMBER, TokenType.STRING, TokenType.REGEXP,\n               TokenType.IDENTIFIER, TokenType.CONST, TokenType.TEMPLATE,\n               TokenType.ILLEGAL];\n\nlet ListHandler = transit.makeWriteHandler({\n  tag: () => \"array\",\n  rep: (v) => v\n});\n\nlet SyntaxHandler = transit.makeWriteHandler({\n  tag: () => \"stx\",\n  rep: (v) => {\n    if (List.isList(v.token)) {\n      return [v.token, v.context.scopeset];\n    } else {\n      let t = transit.objectToMap(v.token);\n      t.set(\"type\", typeMap.indexOf(v.token.type));\n      return [t, v.context.scopeset];\n    }\n  }\n});\nlet SymbolHandler = transit.makeWriteHandler({\n  tag: () => \"symb\",\n  rep: (v) =>  [v.name]\n});\n\nlet writer = transit.writer(\"json\", {\n  handlers: transit.map([\n    List, ListHandler,\n    Syntax, SyntaxHandler,\n    SymbolClass, SymbolHandler\n  ])\n});\n\nfunction makeReader(bindings) {\n  return transit.reader(\"json\", {\n    arrayBuilder: {\n      init: (node) => List().asMutable(),\n      add: (ret, val, node) => ret.push(val),\n      finalize: (ret, node) => ret.asImmutable(),\n      fromArray: (arr, node) => List(arr)\n    },\n    handlers: {\n      \"stx\": (rep) => {\n        if (List.isList(rep[0])) {\n          let token = rep[0];\n          return new Syntax(token, {bindings: bindings, scopeset: rep[1]});\n        } else {\n          let token = transit.mapToObject(rep[0]);\n          token.type = typeMap[rep[0].get(\"type\")];\n          token.slice = rep[0].has(\"slice\") ? transit.mapToObject(rep[0].get(\"slice\")) : undefined;\n          return new Syntax(token, {bindings: bindings, scopeset: rep[1]});\n        }\n      },\n      \"symb\": (rep) => {\n        return Symbol(rep[0]);\n      }\n    }\n  });\n}\n\nexport {\n  makeReader as makeDeserializer, writer as serializer\n};\n"],"sourceRoot":"/source/"}