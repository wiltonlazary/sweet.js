{"version":3,"sources":["token-expander.js"],"names":[],"mappings":"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","file":"token-expander.js","sourcesContent":["import { List } from 'immutable';\nimport { enforestExpr, Enforester } from \"./enforester\";\nimport TermExpander from \"./term-expander.js\";\nimport BindingMap from \"./binding-map.js\";\nimport Env from \"./env\";\nimport Reader from \"./shift-reader\";\nimport * as _ from \"ramda\";\nimport Term, {\n  isEOF, isBindingIdentifier, isBindingPropertyProperty, isBindingPropertyIdentifier, isObjectBinding, isArrayBinding, isFunctionDeclaration, isFunctionExpression,\n  isFunctionTerm, isFunctionWithName, isSyntaxDeclaration, isSyntaxrecDeclaration, isVariableDeclaration,\n  isVariableDeclarationStatement, isImport, isExport\n} from \"./terms\";\nimport { Maybe } from 'ramda-fantasy';\nimport { gensym } from './symbol';\nimport { VarBindingTransform, CompiletimeTransform } from './transforms';\nimport { expect, assert } from \"./errors\";\nimport loadSyntax from './load-syntax';\nimport { Scope, freshScope } from \"./scope\";\n\nconst Just = Maybe.Just;\nconst Nothing = Maybe.Nothing;\n\nconst registerSyntax = (stx, context) => {\n  let newBinding = gensym(stx.val());\n  context.env.set(newBinding.toString(), new VarBindingTransform(stx));\n  context.bindings.add(stx, {\n    binding: newBinding,\n    phase: 0,\n    // skip dup because js allows variable redeclarations\n    // (technically only for `var` but we can let later stages of the pipeline\n    // handle incorrect redeclarations of `const` and `let`)\n    skipDup: true\n  });\n};\n\nlet registerBindings = _.cond([\n  [isBindingIdentifier, ({name}, context) => {\n    registerSyntax(name, context);\n  }],\n  [isBindingPropertyIdentifier, ({binding}, context) => {\n    registerBindings(binding, context);\n  }],\n  [isBindingPropertyProperty, ({binding}, context) => {\n    registerBindings(binding, context);\n  }],\n  [isArrayBinding, ({elements, restElement}, context) => {\n    if (restElement != null) {\n      registerBindings(restElement, context);\n    }\n    elements.forEach(el => {\n      if (el != null) {\n        registerBindings(el, context);\n      }\n    });\n  }],\n  [isObjectBinding, ({properties}, context) => {\n    properties.forEach(prop => registerBindings(prop, context));\n  }],\n  [_.T, binding => assert(false, \"not implemented yet for: \" + binding.type)]\n]);\n\nlet removeScope = _.cond([\n  [isBindingIdentifier, ({name}, scope) => new Term('BindingIdentifier', {\n    name: name.removeScope(scope)\n  })],\n  [isArrayBinding, ({elements, restElement}, scope) => {\n    return new Term('ArrayBinding', {\n      elements: elements.map(el => el == null ? null : removeScope(el, scope)),\n      restElement: restElement == null ? null : removeScope(restElement, scope)\n    });\n  }],\n  [isBindingPropertyIdentifier, ({binding, init}, scope) => new Term('BindingPropertyIdentifier', {\n    binding: removeScope(binding, scope),\n    init\n  })],\n  [isBindingPropertyProperty, ({binding, name}, scope) => new Term('BindingPropertyProperty', {\n    binding: removeScope(binding, scope), name\n  })],\n  [isObjectBinding, ({properties}, scope) => new Term('ObjectBinding', {\n    properties: properties.map(prop => removeScope(prop, scope))\n  })],\n  [_.T, binding => assert(false, \"not implemented yet for: \" + binding.type)]\n]);\n\nfunction findNameInExports(name, exp) {\n  let foundNames = exp.reduce((acc, e) => {\n    if (e.declaration) {\n      return acc.concat(e.declaration.declarators.reduce((acc, decl) => {\n        if (decl.binding.name.val() === name.val()) {\n          return acc.concat(decl.binding.name);\n        }\n        return acc;\n      }, List()));\n    }\n    return acc;\n  }, List());\n  assert(foundNames.size <= 1, 'expecting no more than 1 matching name in exports');\n  return foundNames.get(0);\n}\n\n\nfunction bindImports(impTerm, exModule, context) {\n  let names = [];\n  impTerm.namedImports.forEach(specifier => {\n    let name = specifier.binding.name;\n    let exportName = findNameInExports(name, exModule.exportEntries);\n    if (exportName != null) {\n      let newBinding = gensym(name.val());\n      context.bindings.addForward(name, exportName, newBinding);\n      if (context.store.has(exportName.resolve())) {\n        names.push(name);\n      }\n    }\n    // // TODO: better error\n    // throw 'imported binding ' + name.val() + ' not found in exports of module' + exModule.moduleSpecifier;\n  });\n  return List(names);\n}\n\n\nexport default class TokenExpander {\n  constructor(context) {\n    this.context = context;\n  }\n\n  expand(stxl) {\n    let result = List();\n    if (stxl.size === 0) {\n      return result;\n    }\n    let prev = List();\n    let enf = new Enforester(stxl, prev, this.context);\n    let self = this;\n    while (!enf.done) {\n\n      let term = _.pipe(\n        _.bind(enf.enforest, enf),\n        _.cond([\n          [isVariableDeclarationStatement, term => {\n            // first, remove the use scope from each binding\n            term.declaration.declarators = term.declaration.declarators.map(decl => {\n              return new Term('VariableDeclarator', {\n                binding: removeScope(decl.binding, self.context.useScope),\n                init: decl.init\n              });\n            });\n\n            // syntax id^{a, b} = <init>^{a, b}\n            // ->\n            // syntaxrec id^{a,b,c} = function() { return <<id^{a}>> }\n            // syntaxrec id^{a,b} = <init>^{a,b,c}\n            if (isSyntaxDeclaration(term.declaration)) {\n              // TODO: do stuff\n              let scope = freshScope('nonrec');\n              term.declaration.declarators.forEach(decl => {\n                let name = decl.binding.name;\n                let nameAdded = name.addScope(scope);\n                let nameRemoved = name.removeScope(self.context.currentScope[self.context.currentScope.length - 1]);\n                let newBinding = gensym(name.val());\n                self.context.bindings.addForward(nameAdded, nameRemoved, newBinding);\n                decl.init.body = decl.init.body.map(s => s.addScope(scope, self.context.bindings));\n              });\n            }\n\n            // for syntax declarations we need to load the compiletime value\n            // into the environment\n            if (isSyntaxDeclaration(term.declaration) || isSyntaxrecDeclaration(term.declaration)) {\n              term.declaration.declarators.forEach(decl => {\n                registerBindings(decl.binding, self.context);\n                loadSyntax(decl, self.context, self.context.env);\n              });\n              // do not add syntax declarations to the result\n              return Nothing();\n            } else {\n              // add each binding to the environment\n              term.declaration.declarators.forEach(decl =>\n                registerBindings(decl.binding, self.context)\n              );\n            }\n            return Just(term);\n          }],\n          [isFunctionWithName, term => {\n            term.name = removeScope(term.name, self.context.useScope);\n            registerBindings(term.name, self.context);\n            return Just(term);\n          }],\n          [isImport, term => {\n            let mod = self.context.modules.load(term.moduleSpecifier.val(), self.context);\n            // NOTE: this is a hack for MVP modules\n            if (term.forSyntax) {\n              console.log('import for syntax is not implemented yet');\n              // todo\n              // mod.invoke(self.context);\n            } else {\n              mod.visit(self.context);\n            }\n            let boundNames = bindImports(term, mod, self.context);\n            if (boundNames.size === 0) {\n              return Just(term);\n            }\n            return Nothing();\n          }],\n          [isEOF, Nothing],\n          [_.T, Just]\n        ]),\n        Maybe.maybe(List(), _.identity)\n      )();\n\n      result = result.concat(term);\n    }\n    return result;\n  }\n}\n"],"sourceRoot":"/source/"}