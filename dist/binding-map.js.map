{"version":3,"sources":["binding-map.js"],"names":[],"mappings":";;;;;;;;AAAA;;AACA;;AACA;;;;IAEqB;AACnB,WADmB,UACnB,GAAc;0BADK,YACL;;AACZ,SAAK,IAAL,GAAY,IAAI,GAAJ,EAAZ,CADY;GAAd;;;;;;;eADmB;;wBAQf,WAA0C;UAAnC,uBAAmC;UAA1B,mBAA0B;8BAAnB,QAAmB;UAAnB,uCAAU,qBAAS;;AAC5C,UAAI,UAAU,IAAI,GAAJ,EAAV,CADwC;;AAG5C,UAAI,KAAK,IAAL,CAAU,GAAV,CAAc,OAAd,CAAJ,EAA4B;AAC1B,YAAI,sBAAsB,KAAK,IAAL,CAAU,GAAV,CAAc,OAAd,CAAtB,CADsB;AAE1B,YAAI,WAAW,oBAAoB,IAApB,CAAyB;iBAAK,EAAE,MAAF,CAAS,MAAT,CAAgB,IAAI,OAAJ,CAAY,QAAZ;SAArB,CAApC,EAAiF;AACnF,iBADmF;SAArF;AAGA,aAAK,IAAL,CAAU,GAAV,CAAc,OAAd,EAAuB,oBAAoB,IAApB,CAAyB;AAC9C,kBAAQ,IAAI,OAAJ,CAAY,QAAZ;AACR,mBAAS,OAAT;AACA,iBAAO,oBAAM,OAAN,EAAP;SAHqB,CAAvB,EAL0B;OAA5B,MAUO;AACL,aAAK,IAAL,CAAU,GAAV,CAAc,OAAd,EAAuB,gBAAK,EAAL,CAAQ;AAC7B,kBAAQ,IAAI,OAAJ,CAAY,QAAZ;AACR,mBAAS,OAAT;AACA,iBAAO,oBAAM,OAAN,EAAP;SAHqB,CAAvB,EADK;OAVP;;;;+BAmBS,KAAK,YAAY,SAAoB;UAAX,8DAAQ,iBAAG;;AAC9C,UAAI,UAAU,IAAI,KAAJ,CAAU,KAAV,CADgC;;AAG9C,UAAI,KAAK,IAAL,CAAU,GAAV,CAAc,OAAd,CAAJ,EAA4B;AAC1B,YAAI,sBAAsB,KAAK,IAAL,CAAU,GAAV,CAAc,OAAd,CAAtB,CADsB;AAE1B,aAAK,IAAL,CAAU,GAAV,CAAc,OAAd,EAAuB,oBAAoB,IAApB,CAAyB;AAC9C,kBAAQ,IAAI,OAAJ,CAAY,QAAZ;AACR,mBAAS,OAAT;AACA,iBAAO,oBAAM,EAAN,CAAS,UAAT,CAAP;SAHqB,CAAvB,EAF0B;OAA5B,MAOO;AACL,aAAK,IAAL,CAAU,GAAV,CAAc,OAAd,EAAuB,gBAAK,EAAL,CAAQ;AAC7B,kBAAQ,IAAI,OAAJ,CAAY,QAAZ;AACR,mBAAS,OAAT;AACA,iBAAO,oBAAM,EAAN,CAAS,UAAT,CAAP;SAHqB,CAAvB,EADK;OAPP;;;;;;;wBAkBE,KAAK;AACP,aAAO,KAAK,IAAL,CAAU,GAAV,CAAc,IAAI,KAAJ,CAAU,KAAV,CAArB,CADO;;;;SAnDU","file":"binding-map.js","sourcesContent":["import { List } from \"immutable\";\nimport { expect, assert } from \"./errors\";\nimport { Maybe } from 'ramda-fantasy';\n\nexport default class BindingMap {\n  constructor() {\n    this._map = new Map();\n  }\n\n  // given a syntax object and a binding,\n  // add the binding to the map associating the binding with the syntax object's\n  // scope set\n  add(stx, { binding, phase, skipDup = false }) {\n    let stxName = stx.val();\n\n    if (this._map.has(stxName)) {\n      let scopesetBindingList = this._map.get(stxName);\n      if (skipDup && scopesetBindingList.some(s => s.scopes.equals(stx.context.scopeset))) {\n        return;\n      }\n      this._map.set(stxName, scopesetBindingList.push({\n        scopes: stx.context.scopeset,\n        binding: binding,\n        alias: Maybe.Nothing()\n      }));\n    } else {\n      this._map.set(stxName, List.of({\n        scopes: stx.context.scopeset,\n        binding: binding,\n        alias: Maybe.Nothing()\n      }));\n    }\n  }\n\n  addForward(stx, forwardStx, binding, phase = 0) {\n    let stxName = stx.token.value;\n\n    if (this._map.has(stxName)) {\n      let scopesetBindingList = this._map.get(stxName);\n      this._map.set(stxName, scopesetBindingList.push({\n        scopes: stx.context.scopeset,\n        binding: binding,\n        alias: Maybe.of(forwardStx)\n      }));\n    } else {\n      this._map.set(stxName, List.of({\n        scopes: stx.context.scopeset,\n        binding: binding,\n        alias: Maybe.of(forwardStx)\n      }));\n    }\n\n  }\n\n  // Syntax -> ?List<{ scopes: ScopeSet, binding: Binding }>\n  get(stx) {\n    return this._map.get(stx.token.value);\n  }\n\n}\n"],"sourceRoot":"/source/"}