{"version":3,"sources":["macro-context.js"],"names":[],"mappings":"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","file":"macro-context.js","sourcesContent":["import MapSyntaxReducer from \"./map-syntax-reducer\";\nimport reducer from \"shift-reducer\";\nimport { List } from 'immutable';\nimport { Enforester } from './enforester';\nimport Syntax from './syntax';\nimport * as _ from 'ramda';\nimport { Maybe } from 'ramda-fantasy';\nconst Just = Maybe.Just;\nconst Nothing = Maybe.Nothing;\n\nconst symWrap = Symbol('wrapper');\n\nconst isKind = _.curry((kind, t, v) => {\n  if (t instanceof Syntax) {\n    return t[kind]() && (v == null || t.val() == v);\n  }\n});\n\nconst isKeyword = isKind('isKeyword');\nconst isIdentifier = isKind('isIdentifier');\nconst isNumericLiteral = isKind('isNumericLiteral');\nconst isStringLiteral = isKind('isStringLiteral');\nconst isNullLiteral = isKind('isNullLiteral');\nconst isPunctuator = isKind('isPunctuator');\nconst isRegularExpression = isKind('isRegularExpression');\nconst isBraces = isKind('isBraces');\nconst isBrackets = isKind('isBrackets');\nconst isParens = isKind('isParens');\nconst isDelimiter = isKind('isDelimiter');\n\nconst getLineNumber = t => {\n  if (t instanceof Syntax) {\n    return t.lineNumber();\n  }\n  throw new Error('Line numbers on terms not implemented yet');\n};\n\nconst getVal = t => {\n  if (isDelimiter(t)) {\n    return Nothing();\n  }\n  if (t instanceof Syntax) {\n    return Just(t.val());\n  }\n  return Nothing();\n};\n\nexport class SyntaxOrTermWrapper {\n  constructor(s, context = {}) {\n    this[symWrap] = s;\n    this.context = context;\n  }\n\n  isKeyword(value) {\n    return isKeyword(this[symWrap], value);\n  }\n\n  isIdentifier(value) {\n    return isIdentifier(this[symWrap], value);\n  }\n\n  isNumericLiteral(value) {\n    return isNumericLiteral(this[symWrap], value);\n  }\n\n  isStringLiteral(value) {\n    return isStringLiteral(this[symWrap], value);\n  }\n\n  isNullLiteral(value) {\n    return isNullLiteral(this[symWrap], value);\n  }\n\n  isPunctuator(value) {\n    return isPunctuator(this[symWrap], value);\n  }\n\n  isRegularExpression(value) {\n    return isRegularExpression(this[symWrap], value);\n  }\n\n  isBraces(value) {\n    return isBraces(this[symWrap], value);\n  }\n\n  isBrackets(value) {\n    return isBrackets(this[symWrap], value);\n  }\n\n  isParens(value) {\n    return isParens(this[symWrap], value);\n  }\n\n  isDelimiter(value) {\n    return isDelimiter(this[symWrap], value);\n  }\n\n  lineNumber() {\n    return getLineNumber(this[symWrap]);\n  }\n\n  val() {\n    return getVal(this[symWrap]);\n  }\n\n  inner() {\n    let stx = this[symWrap];\n    if (!isDelimiter(stx)) {\n      throw new Error('Can only get inner syntax on a delimiter');\n    }\n\n    let enf = new Enforester(stx.inner(), List(), this.context);\n    return new MacroContext(enf, 'inner', this.context);\n  }\n}\n\nexport function unwrap(x) {\n  if (x instanceof SyntaxOrTermWrapper) {\n    return x[symWrap];\n  }\n  return x;\n}\n\n/*\nctx :: {\n  of: (Syntax) -> ctx\n  next: (String) -> Syntax or Term\n}\n*/\nexport default class MacroContext {\n  constructor(enf, name, context, useScope, introducedScope) {\n    // todo: perhaps replace with a symbol to keep mostly private?\n    this._enf = enf;\n    this.name = name;\n    this.context = context;\n    if (useScope && introducedScope) {\n      this.noScopes = false;\n      this.useScope = useScope;\n      this.introducedScope = introducedScope;\n    } else {\n      this.noScopes = true;\n    }\n    this[Symbol.iterator] = () => this;\n  }\n\n  next(type = 'Syntax') {\n    if (this._enf.rest.size === 0) {\n      return {\n        done: true,\n        value: null,\n      };\n    }\n    let value;\n    switch(type) {\n      case 'AssignmentExpression':\n      case 'expr':\n        value = this._enf.enforestExpressionLoop();\n        break;\n      case 'Expression':\n        value = this._enf.enforestExpression();\n        break;\n      case 'Syntax':\n        value = this._enf.advance();\n        if (!this.noScopes) {\n          value = value\n            .addScope(this.useScope)\n            .addScope(this.introducedScope, this.context.bindings, { flip: true });\n        }\n        break;\n      default:\n        throw new Error('Unknown term type: ' + type);\n    }\n    return {\n      done: false,\n      value: new SyntaxOrTermWrapper(value, this.context),\n    };\n  }\n}\n"],"sourceRoot":"/source/"}